import { 
  collection, 
  onSnapshot, 
  addDoc, 
  deleteDoc, 
  doc, 
  query, 
  orderBy,
  setDoc,
  Unsubscribe,
  QuerySnapshot,
  DocumentData
} from "firebase/firestore";
import { db } from "./firebase";
import { Expense, User } from '../types';
import { INITIAL_USERS } from '../constants';

const COLLECTIONS = {
  EXPENSES: 'expenses',
  USERS: 'users',
};

// -- Expenses --

export const subscribeExpenses = (callback: (expenses: Expense[]) => void): Unsubscribe => {
  const q = query(collection(db, COLLECTIONS.EXPENSES), orderBy("timestamp", "desc"));
  
  // includeMetadataChanges: true ensures that we get updates for local writes 
  // immediately, even before they are synced to the server (offline support).
  return onSnapshot(q, { includeMetadataChanges: true }, (snapshot: QuerySnapshot<DocumentData>) => {
    const expenses: Expense[] = [];
    snapshot.forEach((doc) => {
      // We store the ID inside the document object for the app to use,
      // but Firestore also has the ID as doc.id.
      // We prioritize doc.id from Firestore as the source of truth.
      expenses.push({ ...doc.data(), id: doc.id } as Expense);
    });
    
    // Log sync status
    if (snapshot.metadata.fromCache) {
      console.log("Expenses loaded from cache. Syncing with server...");
    } else {
      console.log("Expenses synced from server. Count:", expenses.length);
    }
    
    callback(expenses);
  }, (error) => {
    console.error("Error fetching expenses: ", error);
    alert("無法連接到 Firebase，請檢查網路連線。");
  });
};

export const addExpenseToDb = async (expense: Omit<Expense, 'id'>) => {
  try {
    // We let Firestore generate the ID, or we can generate one if we want to setDoc
    // Here we use addDoc which auto-generates ID.
    const docRef = await addDoc(collection(db, COLLECTIONS.EXPENSES), expense);
    console.log("Expense added with ID:", docRef.id);
    return docRef.id;
  } catch (e) {
    console.error("Error adding expense: ", e);
    throw e;
  }
};

export const deleteExpenseFromDb = async (id: string) => {
  try {
    await deleteDoc(doc(db, COLLECTIONS.EXPENSES, id));
  } catch (e) {
    console.error("Error deleting expense: ", e);
    throw e;
  }
};

// -- Users --

export const subscribeUsers = (callback: (users: User[]) => void): Unsubscribe => {
  // We can order users by name or creation time if we added a timestamp field to User.
  // For now, default order.
  const q = collection(db, COLLECTIONS.USERS);
  
  return onSnapshot(q, { includeMetadataChanges: true }, (snapshot: QuerySnapshot<DocumentData>) => {
    const users: User[] = [];
    snapshot.forEach((doc) => {
      users.push({ ...doc.data(), id: doc.id } as User);
    });
    
    // Log sync status
    if (snapshot.metadata.fromCache) {
      console.log("Users loaded from cache. Syncing with server...");
    } else {
      console.log("Users synced from server. Count:", users.length);
    }
    
    // If no users exist in DB (first run), we might want to return INITIAL_USERS
    // However, it's better to actually Initialize the DB with the default user if empty.
    // For the UI, if empty, we can fallback to INITIAL_USERS or show empty.
    // Let's rely on the App logic to handle empty states or seeding.
    callback(users);
  }, (error) => {
    console.error("Error fetching users: ", error);
    alert("無法連接到 Firebase，請檢查網路連線。");
  });
};

export const addUserToDb = async (user: User) => {
  try {
    // Use setDoc to preserve the UUID generated by the frontend if we want, 
    // or use addDoc. The app currently generates UUIDs for users.
    // To keep it simple and consistent with Expense, we use setDoc with the passed ID.
    await setDoc(doc(db, COLLECTIONS.USERS, user.id), user);
    console.log("User added with ID:", user.id);
  } catch (e) {
    console.error("Error adding user: ", e);
    throw e;
  }
};

export const deleteUserFromDb = async (id: string) => {
  try {
    await deleteDoc(doc(db, COLLECTIONS.USERS, id));
  } catch (e) {
    console.error("Error deleting user: ", e);
    throw e;
  }
};

// Helper to seed initial data if needed (optional)
export const seedInitialUser = async () => {
  const initialUser = INITIAL_USERS[0];
  await addUserToDb(initialUser);
};